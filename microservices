Microservices & Distributed Systems


Monolith vs Microservices tradeoffs
Inter-service communication (REST/gRPC)
API Gateway, Service Discovery
Circuit Breakers (Resilience4j / Hystrix)
Event-driven architecture
Saga pattern (for distributed transactions)
Data consistency: eventual vs strong
Shared DB anti-pattern
Caching & rate-limiting
Scalability & fault tolerance

AWS 

S3 vs EFS vs EBS
Lambda basics
RDS, VPC, DNS, load balancing
Auto-scaling & health checks
SNS vs SQS (pub-sub vs queue)
Monitoring & logging: CloudWatch, ELK, tracing with Zipkin/Sleuth

---

 ğŸ§© 1. Decomposition Patterns (Breaking Monolith into Microservices)
Used to decide how to split an application into services.

 ğŸ”¹ a) Decompose by Business Capability
* Each service focuses on a single business capability like *Order Service*, *Payment Service*, *Inventory Service*.
* Helps achieve high cohesion and low coupling.

 ğŸ”¹ b) Decompose by Subdomain (DDD - Domain Driven Design)
* Use domain-driven design (DDD) to divide the system into bounded contexts like *User Context*, *Billing Context*.
* Each context becomes a microservice.

---

 ğŸ”„ 2. Communication Patterns
Microservices must communicate efficiently and reliably.

 ğŸ”¹ a) Synchronous Communication (REST/gRPC)
* Uses HTTP/REST or gRPC for direct, real-time requests.
* Problem: Can lead to tight coupling or latency issues.

 ğŸ”¹ b) Asynchronous Communication (Event-Driven)
* Uses message brokers (Kafka, RabbitMQ, SNS/SQS).
* Improves resilience, scalability, and decoupling.

 ğŸ”¹ c) API Gateway Pattern
* A single entry point for all client requests.
* Handles authentication, routing, load balancing, rate limiting, etc.
* Example: Netflix Zuul, Spring Cloud Gateway, Kong.

---

 âš™ï¸ 3. Database Patterns
Each microservice should have its own data but often needs to share data across services.

 ğŸ”¹ a) Database per Service
* Each service owns its own schema and data.
* Ensures loose coupling and independent scaling.

 ğŸ”¹ b) Shared Database
* Multiple services access a single DB.
* Simpler but introduces tight coupling â€” generally discouraged.

 ğŸ”¹ c) Saga Pattern (for distributed transactions)
* Breaks large transactions into smaller local transactions.
* Uses events or choreography/orchestration to maintain consistency.
* Example: Order â†’ Payment â†’ Inventory â†’ Notification

 ğŸ”¹ d) CQRS (Command Query Responsibility Segregation)
* Separates read and write models for performance and scalability.
* Often used with Event Sourcing.

 ğŸ”¹ e) Event Sourcing
* Stores all changes as a sequence of events instead of just current state.
* Easy to rebuild state, audit, and undo operations.

---

 ğŸ§± 4. Resilience and Fault Tolerance Patterns
Microservices must handle partial failures gracefully.

 ğŸ”¹ a) Circuit Breaker Pattern
* Prevents cascading failures.
* Stops calling a failing service temporarily.
* Libraries: Resilience4j, Hystrix.

 ğŸ”¹ b) Retry Pattern
* Retries failed requests after a certain interval.
* Often combined with exponential backoff.

 ğŸ”¹ c) Bulkhead Pattern
* Isolates failures by creating separate thread pools or containers.
* So failure in one service doesnâ€™t affect others.

 ğŸ”¹ d) Timeout Pattern
* Limits waiting time for a response â€” avoids hanging threads.

---

 ğŸ“¦ 5. Security and Access Patterns

 ğŸ”¹ a) API Gateway Security
* Centralized authentication and authorization using JWT, OAuth2.

 ğŸ”¹ b) Access Token / JWT Pattern
* Each request carries a token to validate user identity.

 ğŸ”¹ c) Service-to-Service Security
* Uses mTLS (mutual TLS) or API keys for inter-service communication.

---

 ğŸ§° 6. Observability Patterns
For monitoring and debugging distributed systems.

 ğŸ”¹ a) Log Aggregation Pattern
* Centralized logging (ELK stack, Splunk).

 ğŸ”¹ b) Distributed Tracing
* Trace requests across multiple services (Jaeger, Zipkin).

 ğŸ”¹ c) Metrics Aggregation
* Collect metrics for health and performance (Prometheus, Grafana).

---

 ğŸš€ 7. Deployment and Scaling Patterns

 ğŸ”¹ a) Service Discovery Pattern
* Automatically finds service instances (Eureka, Consul, Kubernetes DNS).

 ğŸ”¹ b) Sidecar Pattern
* Deploy helper components (like logging or proxy) alongside each service container.

 ğŸ”¹ c) Strangler Fig Pattern
* Gradually replaces parts of a monolith with microservices.

---

 ğŸ§© Summary Table

| Category          | Common Patterns                                  |
| ----------------- | ------------------------------------------------ |
| Decomposition     | By Business Capability, By Subdomain             |
| Communication     | API Gateway, Event-driven, REST                  |
| Database          | Database per Service, Saga, CQRS, Event Sourcing |
| Resilience        | Circuit Breaker, Retry, Bulkhead, Timeout        |
| Security          | API Gateway, JWT, mTLS                           |
| Observability     | Logging, Tracing, Metrics                        |
| Deployment        | Service Discovery, Sidecar, Strangler Fig        |

---
